
### 问题描述
在[[二值化]]找轮廓时，有时会碰到`边框和内容颜色相近`的情况，如下图。

![[颜色相近_示例.png]]

如果直接使用 灰度图+`cv2.adaptiveThreshold`，会丢失轮廓。

```python
# 转化为灰度图
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
# 二值化处理
binary = cv2.adaptiveThreshold(
    gray,
    255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY_INV,
    7,  # 邻域大小
    11    # 常数差值
)
# 使用形态学操作来清理图像
kernel = np.ones((3,3), np.uint8)
# 闭操作，消除孔洞
binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
show_image("binary",binary)
```

结果如下
![[颜色相近_二值化丢失轮廓.png]]


### 解决办法

在[[二值化]]之前，增强对比度

```python
# 增强对比度（直方图均衡）
equalized = cv2.equalizeHist(gray)
```

灰度图增强对比度，结果如下
![[颜色相近_增强对比度.png]]


然后再进行二值化处理

```python
# 二值化处理
binary = cv2.adaptiveThreshold(
    equalized,
    255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY_INV,
    7,  # 邻域大小
    11    # 常数差值
)
# 使用形态学操作来清理图像
kernel = np.ones((3,3), np.uint8)
binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
```

![[颜色相近_增强对比度_二值化保留轮廓.png]]


现在就保留了轮廓，之后可以再根据实际情况，使用形态学操作去除孔洞。

```python
# 膨胀
binary = cv2.dilate(binary, kernel, iterations=1)
binary = cv2.dilate(binary, kernel, iterations=1)
binary = cv2.dilate(binary, kernel, iterations=1)
# 开操作
binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
```

最终结果
![[颜色相近_最终结果.png]]


查找轮廓
![[颜色相近_查找轮廓.png]]